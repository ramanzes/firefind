<?php
//require_once 'modules_class.php';
require_once 'config_class.php';


class fragments {
    public $arrFrags;
    // private $words;
    // private $parentStr;

    protected $config;


    //!на вход поступет релевантый по общей сумме вхождений искомых слов массив полученный в методе search из класса database

public function __construct($data='',$words=''){
    $this->config = new Config();
  //  $this->arrFrags=$this->relevantArrFrags($data,$words);
//    return $this->arrFrags;
}

//сейчас работает поиск по статьям только. неоходимо добавить такой же поиск по разделам, потому что я планирую в описаниях к разделу давать основную инфу а в статьях уточняющую. т.е. в разделах инфа будет качественнее.





// получить первое вхождение слова в строке, по нему сделать фрагмент строки в 255 символов. 30 символов ДО, остальные ПОСЛЕ например.

//ищем следующий фрагмент поступаем точно также. и так до конца строки получаем массив фрагментов.

//упорячиваем фрагменты по релевантности в которых будет больше повторений данного слова. на выходе имеем упорядоченный массив

//метод получить индекс в строке на указанную в параметрах величину сдвига по количеству слов. например на три если number = 3 слова влево, или на три слова вправо.

//вспомогательный метод нужен, чтобы получать нужный фрагмент добавив перед искомым словом если оно первое во фрагменте несколько слов для смысловой нагрузки, и после несколько слов если оно последнее во фрагменте. получаем нужный нам индекс в этой строке.
//number это на сколько слов сдвинуть. to в какую сторону. where=индекс от куда начинать.
private function goToInStr($str,$where,$number,$to='left'){
    $i=0;
    $reg="/\s/";//любой пробельный символ как разделитель слов ,знаки препинания пока не учитываю.
  if($to=='left'){
    $j=$where;
    while (($i<$number)and($j>0)) {
      $j--;
      if (preg_match($reg,$str[$j])) $i++;
    }
  } else
  if ($to=='right') {
    $j=$where;
    while (($i<$number)and($j<strlen($str))) {
      $j++;
      if (preg_match($reg,$str[$j])) $i++;
  }
}
    return $j;
}


//на вход подаются два диапазона, двух фрагментов в виде чисел от b1 до e1, и от b2 до e2. если эти диапазоны пересекаются, значит возврат true иначе false
//полнота пересечения, насколько пересекаемые отрезки актуальны в этом случае, вывод слов. какой из двух отрезков будет лучшим отражением происходящего при одинаковой количественной идентичности.
//будем возвращать количество символов в пересечении. а не просто труфалс.

private function prFrag($b1,$e1,$b2,$e2){

  $l1=$e1-$b1; //общая длина первого фрагмента
  $l2=$e2-$b2; //общая длина второго

  if (($b2<$e1)and($e2>$b1)) {
    $lr=$e1-$b2;     //размер пересечения в символах

  }

if($lr) {
  //получим пересечение в процентах относительно наибольшего фрагмента из этих двух
if ($l1>=$l2){
  $procent=round(($lr/$l1)*100);
} else {
  $procent=round(($lr/$l2)*100);
}

if ($procent >= 80) return 5;
//elseif ($procent >= 70) return 6;
//elseif ($procent >= 60) return 5;
elseif ($procent >= 50) return 3;
//elseif ($procent >= 40) return 3;
//elseif ($procent >= 30) return 2;
elseif ($procent >= 20) return 1;
//elseif ($procent >= 10) return 1;
}
  return false;
}

//3,2,1 можно задать такой приоритет
//создать приоритеты пересечений. например 80% наивысший приоритет. 50% средний. 30% минимальный. меньше уже не рассматривается. в общем задать балы пересечениям.



//получить двумерный ассоциативный массив фрагментов, из переданной строки, где ключами станут каждое из переданных слов в поиске, а элементами, первый: массив отрезков в виде подстрок указанной в конфиге длины; и второй элемент: массивчик из двух чисел его начала, и конца по индексу из родительской строки.
// public function getFragments_v1($str,$words){
//   $words = mb_strtoupper($words); //привести в нижний регистр
//   $words = trim($words);// обрезать пробелы спереди и сзади
//   $words = quotemeta($words); //заковычить специальные символы для работы с sql
//   if ($words=='') return false;
//   $where ='';
//   $arraywords=explode(' ',$words); //разбить строку слов на массив слов
//
// $words=$arraywords;
//
//   $countStr=strlen($str);  //общая длина строки, количество символов каждый из которых и будет представлять собой потенциальный центр фрагментов.
//
//   //чтобы получить фрагмент находим первое вхождение слова. от него отсчитваем количество символов установленное в конфиге для размера фрагмента. и с этого места начинаем поиск следующего фрагмента. и так до конца строки.
// //  $newarr[]=array('fragment'=>'','arrwidth'=>[0,255]);
//
// for ($j=0;$j<count($words);$j++) {
//   $i=0;
//   $k=0;
//   $offset=$k;
// while (($k!==false)and($offset<$countStr))
//  {
//   $k=strpos($str,$words[$j],$offset); //возвращает индекс первого вхождения $word в  строке $str/ третий $offset не обязательный параметр указывает индекс с которого начать искать вхождение. если нет подстроки то возвращается false
//   if ($k!==false){
//   if ($k>0)
//   $begin=$this->goToInStr($str,$k,$this->config->beginfrags,'left');
//   else $begin=0;
//
//   if (($k+$this->config->widthfrags)<$countStr)
//   $end=$this->goToInStr($str,$k+$this->config->widthfrags,$this->config->endfrags,'right');
//   else $end=$countStr;
//
//   $arrfrags[$j]["$words[$j]"][$i][]=substr($str,$begin,$end);// возвращает часть строки например с $begin по $end символ
// $arrfrags[$j]["$words[$j]"][$i][]=$begin;
// $arrfrags[$j]["$words[$j]"][$i][]=$end;
//
// //  $arrfrags[$j]['width'][$i]=array($begin,$end);
//   $i++;
//   $offset=$end;
// }
// }
//   //реализовать установку начала фрагмента на три слова назад, до первого вхождения
// }
//
// return $arrfrags;
// }

//получаем сейчас в таком формате $arrfrags

// array (size=1)
//   'места' =>
//     array (size=4)
//       0 =>
//         array (size=3)
//           0 => string ' с этого места начинаем поиск следующего фрагмента. и так до конца строки. чтобы получить фрагмент находим первое вхождение слова. от него отсчитваем количество символов установленное в конфиге для размера фрагмента. и с этого места начинаем поиск следующего фрагмента. и так до �'... (length=539)
//           1 => int 266
//           2 => int 539
//       1 =>
//         array (size=3)
//           0 => string ' с этого места начинаем поиск следующего фрагмента. и так до конца строки. чтобы получить фрагмент находим первое вхождение слова. от него отсчитваем количество символов установленное в конфиге для размера фрагмента. и с этого места начинаем поиск следующего фрагмента. и так до �'... (length=936)
//           1 => int 667
//           2 => int 940
//       2 =>
//         array (size=3)
//           0 => string ' с этого места начинаем поиск следующего фрагмента. и так до конца строки. чтобы получить фрагмент находим первое вхождение слова. от него отсчитваем количество символов установленное в конфиге для размера фрагмента. и с этого места начинаем поиск следующего фрагмента. и так до �'... (length=535)
//           1 => int 1068
//           2 => int 1341
//       3 =>
//         array (size=3)
//           0 => string ' с этого места начинаем поиск следующего фрагмента. и так до конца строки.' (length=134)
//           1 => int 1469
//           2 => int 1603


//вторая версия получаем просто массив всех фрагментов без привязки их в выводе данных к словам, как в первой версии/ из объекта поиска получаем один массив всех фрагментов для всех слов учавствующих в поисковом запросе

public function getFragments_v2($str,$words){
  $words = mb_strtoupper($words); //привести в регистр
  $words = trim($words);// обрезать пробелы спереди и сзади
  $words = quotemeta($words); //заковычить специальные символы для работы с sql
  if ($words=='') return false;
  $where ='';
  $arraywords=explode(' ',$words); //разбить строку слов на массив слов

$words=$arraywords;

  $countStr=strlen($str);  //общая длина строки.

  //чтобы получить фрагмент находим первое вхождение слова. от него отсчитваем количество символов установленное в конфиге для размера фрагмента. и с этого места начинаем поиск следующего фрагмента. и так до конца строки.
//  $newarr[]=array('fragment'=>'','arrwidth'=>[0,255]);
$i=0;
for ($j=0;$j<count($words);$j++) {
  $k=0;
  $offset=$k;
while (($k!==false)and($offset<$countStr))
 {
  $k=strpos($str,$words[$j],$offset); //возвращает индекс первого вхождения $word в  строке $str/ третий $offset не обязательный параметр указывает индекс с которого начать искать вхождение. если нет подстроки то возвращается false
  if ($k!==false){
  if ($k>0)
  $begin=$this->goToInStr($str,$k,$this->config->beginfrags,'left');
  else $begin=0;

  if (($k+$this->config->widthfrags)<$countStr)
  $end=$this->goToInStr($str,$k+$this->config->widthfrags,$this->config->endfrags,'right');
  else $end=$countStr;
  $arrfrags[$i][]=substr($str,$begin,$end-$begin);// возвращает часть строки например с $begin по $end символ/ второй параметр это именно количество символов вернуть от начала а не по какой символ в строке

$arrfrags[$i][]=$begin;
$arrfrags[$i][]=$end;
$arrfrags[$i][]=substr_count($arrfrags[$i][0],$words[$j]);// учтываем количество вхождений данного слова в этот фрагмент// к этому полю будет добавляться цифры при пересечении.
//  $arrfrags[$j]['width'][$i]=array($begin,$end);
  $i++;
  $offset=$end;
}
}
  //реализовать установку начала фрагмента на три слова назад, до первого вхождения
}

return $arrfrags;
}


//получить упорядоченный массив по релевантности пересечений, готовый для вывода на экран
public function getGoodArrfrag($arrfrags){

  for ($j=0;$j<(count($arrfrags)-1);$j++)
  for ($i=$j+1;$i<count($arrfrags);$i++){ //сравниваем изначально первый элемент $j со всеми поэтому $i от 1 а не 0. Чтобы каждый элемент в итоге сравнить со всеми по пересечениям.
        $res=$this->prFrag($arrfrags[$j][1],$arrfrags[$j][2],$arrfrags[$i][1],$arrfrags[$i][2]);
        if ($res){
          $arrfrags[$j][3]+=$res;   //добавляем переменную в целевой массив, счётчик пересечений текущего сравниваемого элемента со всеми.
          $arrfrags[$i][3]+=$res;  //дублируем этот результат и создаём переменную и в сравниваемый массив, так результат текущего сравнения, сохраняется и учтётся в дальнейшем, когда он сам станет сравниваемым со всеми.
  //        $newarr[]=$arrfrags[$j];
        }
    }
  return $arrfrags;
}



//метод который с помощью метода getFragments и его выхода $arrfrags, создаёт релевантный массив, статей упорядоченных на убываение, где в самом ввеху находится статья с фрагментами, которые имеют наибольшее количество пересечений между другими фрагментами в этом массиве.
public function relevantArrFrags($data,$fields,$words){

  print_r($words);
  echo "<hr>";
print_r($data);
$newdata=$data;

for ($i=0;$i<count($data);$i++)   //цикл по всему массиву data
for ($j=0;$j<count($words);$j++)  //подцикл по массиву искомых слов
foreach ($fields as $key => $value) { //подцикл по полям в которых ищем
  if (is_string($value)){
    $newdata[$i][$value]=$this->getFragments_v2($value,$words);
  }
}

//сейчас у нас идёт поиск по двум строкам, титл и фултекст
//релевантый это как в таком случае когда в тексте пересечения или в титле или и в том и в том.? Или выводим титл того, чьи тексты наиболее релевантнее?

return $newdata;
//$newarr=$this->getFragments($str,$words);
//создать метод который создаёт массив по каждому слову с дополнительным параметром, как количество пересечений между другими участниками массива.
  // foreach ($newarr as $word => $arrfrags) {
  //
  // }

}

}

//так слов в поисковом запросе у нас может несколько под каждое из них у нас будет свой массив фрагментов.
//задача заключается в том, чтобы упорядочить общий массив из всех фрагментов, от всех поисковых слов, по тем фрагментам которые имеют наибольшее количество пересечений из разных слов поиска. Т.е. если в одном фрагменте встречаются сразу несколько слов из поискового запроса, то его приоритет выше чем больше таких совпадений.




?>
